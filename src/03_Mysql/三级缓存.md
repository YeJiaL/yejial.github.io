

![Spring AOP循环依赖](三级缓存.assets/20200403212201923.jpg)

# Spring是如何解决循环依赖问题的？

上面说到Spring是使用三级缓存（Map）解决的循环依赖问题，那具体是怎么做的，看下面的步骤。
假设A依赖B，B依赖A，Spring创建A实例的过程如下：

1、A依次执行**doGetBean方法**、依次查询三个缓存是否存在该bean、没有就createBean，实例化完成（早期引用，未完成属性装配），放入三级缓存中，接着执行**populateBean**方法装配属性，但是发现装配的属性是B对象，走下面步骤。

2、创建B实例，依次执行doGetBean、查询三个缓存、createBean创建实例，接着执行**populateBean**发现属性中需要A对象。

3、再次调用doGetBean创建A实例，查询三个缓存，在三级缓存singletonFactories得到了A的早期引用（在第一步的时候创建出来了），将它放到二级缓存并移除3级缓存并返回，B完成属性装配，一个完整的对象放到一级缓存**singletonObjects**中。

4、B完成之后就回到A了，A得到完整的B，肯定也完成全部初始化，也存入一级缓存中。
**解决了循环依赖问题。**



# 为什么不使用二级缓存?

如果仅仅是解决循环依赖问题，二级缓存也可以，但是如果注入的对象实现了AOP，那么注入到其他bean的时候，不是最终的代理对象，而是原始的。通过三级缓存的ObjectFactory才能实现类最终的代理对象。